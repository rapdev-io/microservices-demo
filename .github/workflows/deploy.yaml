name: Deploy Swagstore Demo

on:
  push:
    branches: [dd-refactor]
  workflow_dispatch:
    inputs:
      deploy_all:
        description: "Deploy all services (bypass change detection)"
        required: false
        type: boolean
        default: false

env:
  commits: '[{"commitId": "${{ github.sha }}" }]'
  repository: "${{ github.repository }}"
  run_number: "${{ github.run_number }}"
  job: ${{ github.job }}
  REPO_NAME: "${{ github.event.repository.name }}"
  GCP_PROJECT: microservices-demo-401016
  GCP_SERVICE_ACCOUNT: microservices-demo-svc@microservices-demo-401016.iam.gserviceaccount.com
  GCP_WORKLOAD_IDENTITY_PROVIDER: "projects/241697928795/locations/global/workloadIdentityPools/microservices-demo-pool/providers/microservices-demo-provider"

permissions:
  id-token: write
  contents: read
  issues: write

jobs:

  detect-changes:
    runs-on: ubuntu-latest
    name: Detect Changes
    outputs:
      changed_services: ${{ steps.changes.outputs.changed_services }}
      has_changes: ${{ steps.changes.outputs.has_changes }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Detect changed services
        id: changes
        run: |
          ALL_SERVICES='["adservice","cartservice","checkoutservice","currencyservice","emailservice","frontend","loadgenerator","paymentservice","productcatalogservice","recommendationservice","shippingservice"]'

          # Manual deploy_all trigger
          if [[ "${{ inputs.deploy_all }}" == "true" ]]; then
            echo "Deploy all requested via workflow_dispatch"
            echo "changed_services=$ALL_SERVICES" >> "$GITHUB_OUTPUT"
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Determine base commit for diff
          BEFORE="${{ github.event.before }}"
          if [[ -z "$BEFORE" || "$BEFORE" == "0000000000000000000000000000000000000000" ]]; then
            echo "No valid before SHA, using HEAD~1"
            BEFORE="HEAD~1"
          fi

          echo "Comparing $BEFORE..HEAD"
          CHANGED_FILES=$(git diff --name-only "$BEFORE"..HEAD || true)

          if [[ -z "$CHANGED_FILES" ]]; then
            echo "No changed files detected, deploying all as fallback"
            echo "changed_services=$ALL_SERVICES" >> "$GITHUB_OUTPUT"
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"

          declare -A SERVICES_MAP

          while IFS= read -r file; do
            # src/<service>/** → that service
            if [[ "$file" =~ ^src/([^/]+)/ ]]; then
              svc="${BASH_REMATCH[1]}"
              SERVICES_MAP["$svc"]=1
            fi

            # pb/demo.proto → proto-dependent services
            if [[ "$file" == "pb/demo.proto" ]]; then
              for svc in adservice checkoutservice emailservice frontend productcatalogservice recommendationservice shippingservice; do
                SERVICES_MAP["$svc"]=1
              done
            fi

            # pb/grpc/health/** → currencyservice, paymentservice
            if [[ "$file" =~ ^pb/grpc/health/ ]]; then
              SERVICES_MAP["currencyservice"]=1
              SERVICES_MAP["paymentservice"]=1
            fi

            # kubernetes-manifests/<service>.yaml → that service
            if [[ "$file" =~ ^kubernetes-manifests/([^/]+)\.yaml$ ]]; then
              svc="${BASH_REMATCH[1]}"
              # Only map known services (skip kustomization.yaml, redis.yaml, etc.)
              case "$svc" in
                adservice|cartservice|checkoutservice|currencyservice|emailservice|frontend|loadgenerator|paymentservice|productcatalogservice|recommendationservice|shippingservice)
                  SERVICES_MAP["$svc"]=1
                  ;;
              esac
            fi
          done <<< "$CHANGED_FILES"

          # Build JSON array
          CHANGED_LIST="["
          first=true
          for svc in "${!SERVICES_MAP[@]}"; do
            if [[ "$first" == "true" ]]; then
              first=false
            else
              CHANGED_LIST+=","
            fi
            CHANGED_LIST+="\"$svc\""
          done
          CHANGED_LIST+="]"

          if [[ "${#SERVICES_MAP[@]}" -eq 0 ]]; then
            echo "No service changes detected"
            echo "changed_services=[]" >> "$GITHUB_OUTPUT"
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
          else
            echo "Changed services: $CHANGED_LIST"
            echo "changed_services=$CHANGED_LIST" >> "$GITHUB_OUTPUT"
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
          fi

  build:
    runs-on: ubuntu-latest
    name: Build
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    environment: Production
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.changed_services) }}
    steps:
      - uses: actions/checkout@v3

      - name: Google Cloud Platform Authentication
        id: auth
        uses: google-github-actions/auth@v1
        with:
          create_credentials_file: "true"
          workload_identity_provider: "${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}"
          service_account: "${{ env.GCP_SERVICE_ACCOUNT }}"

      - name: Docker auth
        run: gcloud auth configure-docker --quiet

      - name: Build and push ${{ matrix.service }}
        run: |
          IMAGE="gcr.io/${{ env.GCP_PROJECT }}/${{ matrix.service }}:${{ github.sha }}"

          # cartservice has a nested build context
          if [[ "${{ matrix.service }}" == "cartservice" ]]; then
            BUILD_CONTEXT="src/cartservice/src"
          else
            BUILD_CONTEXT="src/${{ matrix.service }}"
          fi

          docker build --platform linux/amd64 -t "$IMAGE" "$BUILD_CONTEXT"
          docker push "$IMAGE"

  test:
    runs-on: ubuntu-latest
    name: Test
    needs: build
    if: needs.build.result == 'success'
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: SonarCloud Scan
        continue-on-error: true
        uses: SonarSource/sonarqube-scan-action@v6
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: https://sonarcloud.io

      - name: Run JUnit Tests
        continue-on-error: true
        run: bash tests/junit-tests.sh

      - name: Publish Test Results
        if: always()
        run: |
          echo "## JUnit Test Results" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Parse results from XML
          TESTS=$(grep -oP 'tests="\K[^"]+' test-results/results.xml | head -1)
          FAILURES=$(grep -oP 'failures="\K[^"]+' test-results/results.xml | head -1)
          PASSED=$((TESTS - FAILURES))

          echo "| Status | Count |" >> "$GITHUB_STEP_SUMMARY"
          echo "|--------|-------|" >> "$GITHUB_STEP_SUMMARY"
          echo "| Passed | $PASSED |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Failed | $FAILURES |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Total  | $TESTS |" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # List individual test cases
          echo "### Test Cases" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          grep -oP 'name="\K[^"]+' test-results/results.xml | tail -n +2 | while read -r name; do
            if grep -q "testcase name=\"$name\".*<failure" test-results/results.xml; then
              echo "- :x: $name" >> "$GITHUB_STEP_SUMMARY"
            else
              echo "- :white_check_mark: $name" >> "$GITHUB_STEP_SUMMARY"
            fi
          done

  changecontrol:
    runs-on: ubuntu-latest
    name: Change Control
    needs: test
    if: needs.test.result == 'success'
    environment: Production
    steps:
      - name: ServiceNow Change
        uses: ServiceNow/servicenow-devops-change@v2.0.0
        with:
          devops-integration-user-name: ${{ secrets.SN_DEVOPS_USER }}
          devops-integration-user-password: ${{ secrets.SN_DEVOPS_PASSWORD }}
          instance-url: ${{ secrets.SN_INSTANCE_URL }}
          tool-id: ${{ secrets.SN_ORCHESTRATION_TOOL_ID }}
          context-github: ${{ toJSON(github) }}
          job-name: 'Change Control'
          change-request: '{"setCloseCode":"true","attributes":{"short_description":"Automated Software Deployment","description":"Automated Software Deployment.","assignment_group":"a715cd759f2002002920bde8132e7018","cmdb_ci":"d1c811ca1b757910de9785507e4bcbfe","implementation_plan":"Software update is tested and results can be found in Test Summaries Tab; When the change is approved the implementation happens automated by the CICD pipeline within the change planned start and end time window.","backout_plan":"When software fails in production, the previous software release will be re-deployed.","test_plan":"Testing if the software was successfully deployed"}}'
          interval: '5'
          timeout: '3600'
          changeCreationTimeOut: '3600'
          abortOnChangeCreationFailure: true
          abortOnChangeStepTimeout: true

  deployment:
    runs-on: ubuntu-latest
    name: Prod Deploy
    needs: [detect-changes, changecontrol]
    if: needs.changecontrol.result == 'success'
    environment: Production
    steps:
      - uses: actions/checkout@v3

      - name: Google Cloud Platform Authentication
        id: auth
        uses: google-github-actions/auth@v1
        with:
          create_credentials_file: "true"
          workload_identity_provider: "${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}"
          service_account: "${{ env.GCP_SERVICE_ACCOUNT }}"

      - uses: simenandre/setup-gke-gcloud-auth-plugin@v1

      - uses: google-github-actions/get-gke-credentials@v1
        with:
          cluster_name: microservices-demo
          location: us-central1-a

      - name: Deploy changed services
        run: |
          CHANGED='${{ needs.detect-changes.outputs.changed_services }}'
          SERVICES=$(echo "$CHANGED" | jq -r '.[]')

          for SERVICE in $SERVICES; do
            echo "========================================="
            echo "Deploying $SERVICE"
            echo "========================================="

            IMAGE="gcr.io/${{ env.GCP_PROJECT }}/${SERVICE}:${{ github.sha }}"

            # Apply the manifest (picks up any manifest changes)
            kubectl apply -f "kubernetes-manifests/${SERVICE}.yaml"

            # Determine container name
            if [[ "$SERVICE" == "loadgenerator" ]]; then
              CONTAINER="main"
            else
              CONTAINER="server"
            fi

            # Update the image to the newly built GCR image
            kubectl set image "deployment/${SERVICE}" "${CONTAINER}=${IMAGE}"

            # Wait for rollout
            kubectl rollout status "deployment/${SERVICE}" --timeout=300s
          done
